{"ast":null,"code":"\"use client\";\n\n// packages/react/toast/src/Toast.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport * as DismissableLayer from \"@radix-ui/react-dismissable-layer\";\nimport { Portal } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(`Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`);\n  }\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */jsx(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    hotkey = VIEWPORT_DEFAULT_HOTKEY,\n    label = \"Notifications ({hotkey})\",\n    ...viewportProps\n  } = props;\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) ref.current?.focus();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(({\n    tabbingDirection\n  }) => {\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n          if (targetIsViewport && isTabbingBackwards) {\n            headFocusProxyRef.current?.focus();\n            return;\n          }\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();\n          }\n        }\n      };\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */jsxs(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */jsx(Primitive.ol, {\n        tabIndex: -1,\n        ...viewportProps,\n        ref: composedRefs\n      })\n    }), hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    onFocusFromOutsideViewport,\n    ...proxyProps\n  } = props;\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(VisuallyHidden, {\n    \"aria-hidden\": true,\n    tabIndex: 0,\n    ...proxyProps,\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  });\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    ...toastProps\n  } = props;\n  const [open = true, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(ToastImpl, {\n      open,\n      ...toastProps,\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: useCallbackRef(props.onPause),\n      onResume: useCallbackRef(props.onResume),\n      onSwipeStart: composeEventHandlers(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: composeEventHandlers(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", `${y}px`);\n      }),\n      onSwipeCancel: composeEventHandlers(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: composeEventHandlers(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", `${y}px`);\n        setOpen(false);\n      })\n    })\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    type = \"foreground\",\n    duration: durationProp,\n    open,\n    onClose,\n    onEscapeKeyDown,\n    onPause,\n    onResume,\n    onSwipeStart,\n    onSwipeMove,\n    onSwipeCancel,\n    onSwipeEnd,\n    ...toastProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = useCallbackRef(() => {\n    const isFocusInToast = node?.contains(document.activeElement);\n    if (isFocusInToast) context.viewport?.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume?.();\n      };\n      const handlePause = () => {\n        const elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause?.();\n      };\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [announceTextContent && /* @__PURE__ */jsx(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      \"aria-atomic\": true,\n      children: announceTextContent\n    }), /* @__PURE__ */jsx(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal(/* @__PURE__ */jsx(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */jsx(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */jsx(Primitive.li, {\n            role: \"status\",\n            \"aria-live\": \"off\",\n            \"aria-atomic\": true,\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection,\n            ...toastProps,\n            ref: composedRefs,\n            style: {\n              userSelect: \"none\",\n              touchAction: \"none\",\n              ...props.style\n            },\n            onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown?.(event.nativeEvent);\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          })\n        })\n      }), context.viewport)\n    })]\n  });\n});\nvar ToastAnnounce = props => {\n  const {\n    __scopeToast,\n    children,\n    ...announceProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */jsx(Portal, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(VisuallyHidden, {\n      ...announceProps,\n      children: renderAnnounceText && /* @__PURE__ */jsxs(Fragment, {\n        children: [context.label, \" \", children]\n      })\n    })\n  });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...titleProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...titleProps,\n    ref: forwardedRef\n  });\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...descriptionProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...descriptionProps,\n    ref: forwardedRef\n  });\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n    altText,\n    ...actionProps\n  } = props;\n  if (!altText.trim()) {\n    console.error(`Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`);\n    return null;\n  }\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */jsx(ToastClose, {\n      ...actionProps,\n      ref: forwardedRef\n    })\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...closeProps\n  } = props;\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      ...closeProps,\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n    })\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    altText,\n    ...announceExcludeProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0,\n    ...announceExcludeProps,\n    ref: forwardedRef\n  });\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, {\n  discrete\n}) {\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = (delta, direction, threshold = 0) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };","map":{"version":3,"names":["React","ReactDOM","composeEventHandlers","useComposedRefs","createCollection","createContextScope","DismissableLayer","Portal","Presence","Primitive","dispatchDiscreteCustomEvent","useCallbackRef","useControllableState","useLayoutEffect","VisuallyHidden","Fragment","jsx","jsxs","PROVIDER_NAME","Collection","useCollection","createCollectionScope","createToastContext","createToastScope","ToastProviderProvider","useToastProviderContext","ToastProvider","props","__scopeToast","label","duration","swipeDirection","swipeThreshold","children","viewport","setViewport","useState","toastCount","setToastCount","isFocusedToastEscapeKeyDownRef","useRef","isClosePausedRef","trim","console","error","Provider","scope","onViewportChange","onToastAdd","useCallback","prevCount","onToastRemove","displayName","VIEWPORT_NAME","VIEWPORT_DEFAULT_HOTKEY","VIEWPORT_PAUSE","VIEWPORT_RESUME","ToastViewport","forwardRef","forwardedRef","hotkey","viewportProps","context","getItems","wrapperRef","headFocusProxyRef","tailFocusProxyRef","ref","composedRefs","hotkeyLabel","join","replace","hasToasts","useEffect","handleKeyDown","event","isHotkeyPressed","every","key","code","current","focus","document","addEventListener","removeEventListener","wrapper","handlePause","pauseEvent","CustomEvent","dispatchEvent","handleResume","resumeEvent","handleFocusOutResume","isFocusMovingOutside","contains","relatedTarget","handlePointerLeaveResume","isFocusInside","activeElement","window","getSortedTabbableCandidates","tabbingDirection","toastItems","tabbableCandidates","map","toastItem","toastNode","toastTabbableCandidates","getTabbableCandidates","reverse","flat","isMetaKey","altKey","ctrlKey","metaKey","isTabKey","focusedElement","isTabbingBackwards","shiftKey","targetIsViewport","target","sortedCandidates","index","findIndex","candidate","focusFirst","slice","preventDefault","Branch","role","tabIndex","style","pointerEvents","FocusProxy","onFocusFromOutsideViewport","Slot","ol","FOCUS_PROXY_NAME","proxyProps","position","onFocus","prevFocusedElement","isFocusFromOutsideViewport","TOAST_NAME","TOAST_SWIPE_START","TOAST_SWIPE_MOVE","TOAST_SWIPE_CANCEL","TOAST_SWIPE_END","Toast","forceMount","open","openProp","defaultOpen","onOpenChange","toastProps","setOpen","prop","defaultProp","onChange","present","ToastImpl","onClose","onPause","onResume","onSwipeStart","currentTarget","setAttribute","onSwipeMove","x","y","detail","delta","setProperty","onSwipeCancel","removeProperty","onSwipeEnd","ToastInteractiveProvider","useToastInteractiveContext","type","durationProp","onEscapeKeyDown","node","setNode","node2","pointerStartRef","swipeDeltaRef","closeTimerStartTimeRef","closeTimerRemainingTimeRef","closeTimerRef","handleClose","isFocusInToast","startTimer","duration2","Infinity","clearTimeout","Date","getTime","setTimeout","elapsedTime","announceTextContent","useMemo","getAnnounceTextContent","ToastAnnounce","createPortal","ItemSlot","Root","asChild","li","userSelect","touchAction","onKeyDown","nativeEvent","defaultPrevented","onPointerDown","button","clientX","clientY","onPointerMove","hasSwipeMoveStarted","Boolean","isHorizontalSwipe","includes","clamp","Math","min","max","clampedX","clampedY","moveStartBuffer","pointerType","eventDetail","originalEvent","handleAndDispatchCustomEvent","discrete","isDeltaInDirection","setPointerCapture","pointerId","abs","onPointerUp","hasPointerCapture","releasePointerCapture","toast","event2","once","announceProps","renderAnnounceText","setRenderAnnounceText","isAnnounced","setIsAnnounced","useNextFrame","timer","TITLE_NAME","ToastTitle","titleProps","div","DESCRIPTION_NAME","ToastDescription","descriptionProps","ACTION_NAME","ToastAction","altText","actionProps","ToastAnnounceExclude","ToastClose","CLOSE_NAME","closeProps","interactiveContext","onClick","announceExcludeProps","container","textContent","childNodes","Array","from","forEach","nodeType","TEXT_NODE","push","isHTMLElement","isHidden","ariaHidden","hidden","display","isExcluded","dataset","radixToastAnnounceExclude","radixToastAnnounceAlt","name","handler","bubbles","cancelable","direction","threshold","deltaX","deltaY","isDeltaX","callback","fn","raf1","raf2","requestAnimationFrame","cancelAnimationFrame","ELEMENT_NODE","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","candidates","previouslyFocusedElement","some","Viewport","Root2","Title","Description","Action","Close"],"sources":["C:\\Users\\seahs\\repos\\worldcoin-app\\node_modules\\@radix-ui\\react-toast\\src\\Toast.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ElementRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `†` and `t !== †`\n        const isHotkeyPressed = hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open = true, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ElementRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],"mappings":";;;AAAA,YAAYA,KAAA,MAAW;AACvB,YAAYC,QAAA,MAAc;AAC1B,SAASC,oBAAA,QAA4B;AACrC,SAASC,eAAA,QAAuB;AAChC,SAASC,gBAAA,QAAwB;AACjC,SAASC,kBAAA,QAA0B;AACnC,YAAYC,gBAAA,MAAsB;AAClC,SAASC,MAAA,QAAc;AACvB,SAASC,QAAA,QAAgB;AACzB,SAASC,SAAA,EAAWC,2BAAA,QAAmC;AACvD,SAASC,cAAA,QAAsB;AAC/B,SAASC,oBAAA,QAA4B;AACrC,SAASC,eAAA,QAAuB;AAChC,SAASC,cAAA,QAAsB;AA+EzB,SAwcAC,QAAA,EAxcAC,GAAA,EA0LAC,IAAA,QA1LA;AAvEN,IAAMC,aAAA,GAAgB;AAEtB,IAAM,CAACC,UAAA,EAAYC,aAAA,EAAeC,qBAAqB,IAAIjB,gBAAA,CAA+B,OAAO;AAkBjG,IAAM,CAACkB,kBAAA,EAAoBC,gBAAgB,IAAIlB,kBAAA,CAAmB,SAAS,CAACgB,qBAAqB,CAAC;AAClG,IAAM,CAACG,qBAAA,EAAuBC,uBAAuB,IACnDH,kBAAA,CAA8CJ,aAAa;AA2B7D,IAAMQ,aAAA,GAA+CC,KAAA,IAA2C;EAC9F,MAAM;IACJC,YAAA;IACAC,KAAA,GAAQ;IACRC,QAAA,GAAW;IACXC,cAAA,GAAiB;IACjBC,cAAA,GAAiB;IACjBC;EACF,IAAIN,KAAA;EACJ,MAAM,CAACO,QAAA,EAAUC,WAAW,IAAUnC,KAAA,CAAAoC,QAAA,CAAsC,IAAI;EAChF,MAAM,CAACC,UAAA,EAAYC,aAAa,IAAUtC,KAAA,CAAAoC,QAAA,CAAS,CAAC;EACpD,MAAMG,8BAAA,GAAuCvC,KAAA,CAAAwC,MAAA,CAAO,KAAK;EACzD,MAAMC,gBAAA,GAAyBzC,KAAA,CAAAwC,MAAA,CAAO,KAAK;EAE3C,IAAI,CAACX,KAAA,CAAMa,IAAA,CAAK,GAAG;IACjBC,OAAA,CAAQC,KAAA,CACN,wCAAwC1B,aAAa,oCACvD;EACF;EAEA,OACE,eAAAF,GAAA,CAACG,UAAA,CAAW0B,QAAA,EAAX;IAAoBC,KAAA,EAAOlB,YAAA;IAC1BK,QAAA,iBAAAjB,GAAA,CAACQ,qBAAA;MACCsB,KAAA,EAAOlB,YAAA;MACPC,KAAA;MACAC,QAAA;MACAC,cAAA;MACAC,cAAA;MACAK,UAAA;MACAH,QAAA;MACAa,gBAAA,EAAkBZ,WAAA;MAClBa,UAAA,EAAkBhD,KAAA,CAAAiD,WAAA,CAAY,MAAMX,aAAA,CAAeY,SAAA,IAAcA,SAAA,GAAY,CAAC,GAAG,EAAE;MACnFC,aAAA,EAAqBnD,KAAA,CAAAiD,WAAA,CAAY,MAAMX,aAAA,CAAeY,SAAA,IAAcA,SAAA,GAAY,CAAC,GAAG,EAAE;MACtFX,8BAAA;MACAE,gBAAA;MAECR;IAAA,CACH;EAAA,CACF;AAEJ;AAEAP,aAAA,CAAc0B,WAAA,GAAclC,aAAA;AAM5B,IAAMmC,aAAA,GAAgB;AACtB,IAAMC,uBAAA,GAA0B,CAAC,IAAI;AACrC,IAAMC,cAAA,GAAiB;AACvB,IAAMC,eAAA,GAAkB;AAkBxB,IAAMC,aAAA,GAAsBzD,KAAA,CAAA0D,UAAA,CAC1B,CAAC/B,KAAA,EAAwCgC,YAAA,KAAiB;EACxD,MAAM;IACJ/B,YAAA;IACAgC,MAAA,GAASN,uBAAA;IACTzB,KAAA,GAAQ;IACR,GAAGgC;EACL,IAAIlC,KAAA;EACJ,MAAMmC,OAAA,GAAUrC,uBAAA,CAAwB4B,aAAA,EAAezB,YAAY;EACnE,MAAMmC,QAAA,GAAW3C,aAAA,CAAcQ,YAAY;EAC3C,MAAMoC,UAAA,GAAmBhE,KAAA,CAAAwC,MAAA,CAAuB,IAAI;EACpD,MAAMyB,iBAAA,GAA0BjE,KAAA,CAAAwC,MAAA,CAA0B,IAAI;EAC9D,MAAM0B,iBAAA,GAA0BlE,KAAA,CAAAwC,MAAA,CAA0B,IAAI;EAC9D,MAAM2B,GAAA,GAAYnE,KAAA,CAAAwC,MAAA,CAA6B,IAAI;EACnD,MAAM4B,YAAA,GAAejE,eAAA,CAAgBwD,YAAA,EAAcQ,GAAA,EAAKL,OAAA,CAAQf,gBAAgB;EAChF,MAAMsB,WAAA,GAAcT,MAAA,CAAOU,IAAA,CAAK,GAAG,EAAEC,OAAA,CAAQ,QAAQ,EAAE,EAAEA,OAAA,CAAQ,UAAU,EAAE;EAC7E,MAAMC,SAAA,GAAYV,OAAA,CAAQzB,UAAA,GAAa;EAEjCrC,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpB,MAAMC,aAAA,GAAiBC,KAAA,IAAyB;MAG9C,MAAMC,eAAA,GAAkBhB,MAAA,CAAOiB,KAAA,CAAOC,GAAA,IAASH,KAAA,CAAcG,GAAG,KAAKH,KAAA,CAAMI,IAAA,KAASD,GAAG;MACvF,IAAIF,eAAA,EAAiBT,GAAA,CAAIa,OAAA,EAASC,KAAA,CAAM;IAC1C;IACAC,QAAA,CAASC,gBAAA,CAAiB,WAAWT,aAAa;IAClD,OAAO,MAAMQ,QAAA,CAASE,mBAAA,CAAoB,WAAWV,aAAa;EACpE,GAAG,CAACd,MAAM,CAAC;EAEL5D,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpB,MAAMY,OAAA,GAAUrB,UAAA,CAAWgB,OAAA;IAC3B,MAAM9C,QAAA,GAAWiC,GAAA,CAAIa,OAAA;IACrB,IAAIR,SAAA,IAAaa,OAAA,IAAWnD,QAAA,EAAU;MACpC,MAAMoD,WAAA,GAAcA,CAAA,KAAM;QACxB,IAAI,CAACxB,OAAA,CAAQrB,gBAAA,CAAiBuC,OAAA,EAAS;UACrC,MAAMO,UAAA,GAAa,IAAIC,WAAA,CAAYjC,cAAc;UACjDrB,QAAA,CAASuD,aAAA,CAAcF,UAAU;UACjCzB,OAAA,CAAQrB,gBAAA,CAAiBuC,OAAA,GAAU;QACrC;MACF;MAEA,MAAMU,YAAA,GAAeA,CAAA,KAAM;QACzB,IAAI5B,OAAA,CAAQrB,gBAAA,CAAiBuC,OAAA,EAAS;UACpC,MAAMW,WAAA,GAAc,IAAIH,WAAA,CAAYhC,eAAe;UACnDtB,QAAA,CAASuD,aAAA,CAAcE,WAAW;UAClC7B,OAAA,CAAQrB,gBAAA,CAAiBuC,OAAA,GAAU;QACrC;MACF;MAEA,MAAMY,oBAAA,GAAwBjB,KAAA,IAAsB;QAClD,MAAMkB,oBAAA,GAAuB,CAACR,OAAA,CAAQS,QAAA,CAASnB,KAAA,CAAMoB,aAA4B;QACjF,IAAIF,oBAAA,EAAsBH,YAAA,CAAa;MACzC;MAEA,MAAMM,wBAAA,GAA2BA,CAAA,KAAM;QACrC,MAAMC,aAAA,GAAgBZ,OAAA,CAAQS,QAAA,CAASZ,QAAA,CAASgB,aAAa;QAC7D,IAAI,CAACD,aAAA,EAAeP,YAAA,CAAa;MACnC;MAGAL,OAAA,CAAQF,gBAAA,CAAiB,WAAWG,WAAW;MAC/CD,OAAA,CAAQF,gBAAA,CAAiB,YAAYS,oBAAoB;MACzDP,OAAA,CAAQF,gBAAA,CAAiB,eAAeG,WAAW;MACnDD,OAAA,CAAQF,gBAAA,CAAiB,gBAAgBa,wBAAwB;MACjEG,MAAA,CAAOhB,gBAAA,CAAiB,QAAQG,WAAW;MAC3Ca,MAAA,CAAOhB,gBAAA,CAAiB,SAASO,YAAY;MAC7C,OAAO,MAAM;QACXL,OAAA,CAAQD,mBAAA,CAAoB,WAAWE,WAAW;QAClDD,OAAA,CAAQD,mBAAA,CAAoB,YAAYQ,oBAAoB;QAC5DP,OAAA,CAAQD,mBAAA,CAAoB,eAAeE,WAAW;QACtDD,OAAA,CAAQD,mBAAA,CAAoB,gBAAgBY,wBAAwB;QACpEG,MAAA,CAAOf,mBAAA,CAAoB,QAAQE,WAAW;QAC9Ca,MAAA,CAAOf,mBAAA,CAAoB,SAASM,YAAY;MAClD;IACF;EACF,GAAG,CAAClB,SAAA,EAAWV,OAAA,CAAQrB,gBAAgB,CAAC;EAExC,MAAM2D,2BAAA,GAAoCpG,KAAA,CAAAiD,WAAA,CACxC,CAAC;IAAEoD;EAAiB,MAAsD;IACxE,MAAMC,UAAA,GAAavC,QAAA,CAAS;IAC5B,MAAMwC,kBAAA,GAAqBD,UAAA,CAAWE,GAAA,CAAKC,SAAA,IAAc;MACvD,MAAMC,SAAA,GAAYD,SAAA,CAAUtC,GAAA,CAAIa,OAAA;MAChC,MAAM2B,uBAAA,GAA0B,CAACD,SAAA,EAAW,GAAGE,qBAAA,CAAsBF,SAAS,CAAC;MAC/E,OAAOL,gBAAA,KAAqB,aACxBM,uBAAA,GACAA,uBAAA,CAAwBE,OAAA,CAAQ;IACtC,CAAC;IACD,QACER,gBAAA,KAAqB,aAAaE,kBAAA,CAAmBM,OAAA,CAAQ,IAAIN,kBAAA,EACjEO,IAAA,CAAK;EACT,GACA,CAAC/C,QAAQ,CACX;EAEM/D,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpB,MAAMvC,QAAA,GAAWiC,GAAA,CAAIa,OAAA;IAIrB,IAAI9C,QAAA,EAAU;MACZ,MAAMwC,aAAA,GAAiBC,KAAA,IAAyB;QAC9C,MAAMoC,SAAA,GAAYpC,KAAA,CAAMqC,MAAA,IAAUrC,KAAA,CAAMsC,OAAA,IAAWtC,KAAA,CAAMuC,OAAA;QACzD,MAAMC,QAAA,GAAWxC,KAAA,CAAMG,GAAA,KAAQ,SAAS,CAACiC,SAAA;QAEzC,IAAII,QAAA,EAAU;UACZ,MAAMC,cAAA,GAAiBlC,QAAA,CAASgB,aAAA;UAChC,MAAMmB,kBAAA,GAAqB1C,KAAA,CAAM2C,QAAA;UACjC,MAAMC,gBAAA,GAAmB5C,KAAA,CAAM6C,MAAA,KAAWtF,QAAA;UAI1C,IAAIqF,gBAAA,IAAoBF,kBAAA,EAAoB;YAC1CpD,iBAAA,CAAkBe,OAAA,EAASC,KAAA,CAAM;YACjC;UACF;UAEA,MAAMoB,gBAAA,GAAmBgB,kBAAA,GAAqB,cAAc;UAC5D,MAAMI,gBAAA,GAAmBrB,2BAAA,CAA4B;YAAEC;UAAiB,CAAC;UACzE,MAAMqB,KAAA,GAAQD,gBAAA,CAAiBE,SAAA,CAAWC,SAAA,IAAcA,SAAA,KAAcR,cAAc;UACpF,IAAIS,UAAA,CAAWJ,gBAAA,CAAiBK,KAAA,CAAMJ,KAAA,GAAQ,CAAC,CAAC,GAAG;YACjD/C,KAAA,CAAMoD,cAAA,CAAe;UACvB,OAAO;YAILV,kBAAA,GACIpD,iBAAA,CAAkBe,OAAA,EAASC,KAAA,CAAM,IACjCf,iBAAA,CAAkBc,OAAA,EAASC,KAAA,CAAM;UACvC;QACF;MACF;MAGA/C,QAAA,CAASiD,gBAAA,CAAiB,WAAWT,aAAa;MAClD,OAAO,MAAMxC,QAAA,CAASkD,mBAAA,CAAoB,WAAWV,aAAa;IACpE;EACF,GAAG,CAACX,QAAA,EAAUqC,2BAA2B,CAAC;EAE1C,OACE,eAAAnF,IAAA,CAAkBX,gBAAA,CAAA0H,MAAA,EAAjB;IACC7D,GAAA,EAAKH,UAAA;IACLiE,IAAA,EAAK;IACL,cAAYpG,KAAA,CAAM0C,OAAA,CAAQ,YAAYF,WAAW;IAEjD6D,QAAA,EAAU;IAGVC,KAAA,EAAO;MAAEC,aAAA,EAAe5D,SAAA,GAAY,SAAY;IAAO;IAEtDvC,QAAA,GAAAuC,SAAA,IACC,eAAAxD,GAAA,CAACqH,UAAA;MACClE,GAAA,EAAKF,iBAAA;MACLqE,0BAAA,EAA4BA,CAAA,KAAM;QAChC,MAAM/B,kBAAA,GAAqBH,2BAAA,CAA4B;UACrDC,gBAAA,EAAkB;QACpB,CAAC;QACDwB,UAAA,CAAWtB,kBAAkB;MAC/B;IAAA,CACF,GAMF,eAAAvF,GAAA,CAACG,UAAA,CAAWoH,IAAA,EAAX;MAAgBzF,KAAA,EAAOlB,YAAA;MACtBK,QAAA,iBAAAjB,GAAA,CAACP,SAAA,CAAU+H,EAAA,EAAV;QAAaN,QAAA,EAAU;QAAK,GAAGrE,aAAA;QAAeM,GAAA,EAAKC;MAAA,CAAc;IAAA,CACpE,GACCI,SAAA,IACC,eAAAxD,GAAA,CAACqH,UAAA;MACClE,GAAA,EAAKD,iBAAA;MACLoE,0BAAA,EAA4BA,CAAA,KAAM;QAChC,MAAM/B,kBAAA,GAAqBH,2BAAA,CAA4B;UACrDC,gBAAA,EAAkB;QACpB,CAAC;QACDwB,UAAA,CAAWtB,kBAAkB;MAC/B;IAAA,CACF;EAAA,CAEJ;AAEJ,CACF;AAEA9C,aAAA,CAAcL,WAAA,GAAcC,aAAA;AAI5B,IAAMoF,gBAAA,GAAmB;AAQzB,IAAMJ,UAAA,GAAmBrI,KAAA,CAAA0D,UAAA,CACvB,CAAC/B,KAAA,EAAOgC,YAAA,KAAiB;EACvB,MAAM;IAAE/B,YAAA;IAAc0G,0BAAA;IAA4B,GAAGI;EAAW,IAAI/G,KAAA;EACpE,MAAMmC,OAAA,GAAUrC,uBAAA,CAAwBgH,gBAAA,EAAkB7G,YAAY;EAEtE,OACE,eAAAZ,GAAA,CAACF,cAAA;IACC,eAAW;IACXoH,QAAA,EAAU;IACT,GAAGQ,UAAA;IACJvE,GAAA,EAAKR,YAAA;IAELwE,KAAA,EAAO;MAAEQ,QAAA,EAAU;IAAQ;IAC3BC,OAAA,EAAUjE,KAAA,IAAU;MAClB,MAAMkE,kBAAA,GAAqBlE,KAAA,CAAMoB,aAAA;MACjC,MAAM+C,0BAAA,GAA6B,CAAChF,OAAA,CAAQ5B,QAAA,EAAU4D,QAAA,CAAS+C,kBAAkB;MACjF,IAAIC,0BAAA,EAA4BR,0BAAA,CAA2B;IAC7D;EAAA,CACF;AAEJ,CACF;AAEAD,UAAA,CAAWjF,WAAA,GAAcqF,gBAAA;AAMzB,IAAMM,UAAA,GAAa;AACnB,IAAMC,iBAAA,GAAoB;AAC1B,IAAMC,gBAAA,GAAmB;AACzB,IAAMC,kBAAA,GAAqB;AAC3B,IAAMC,eAAA,GAAkB;AAcxB,IAAMC,KAAA,GAAcpJ,KAAA,CAAA0D,UAAA,CAClB,CAAC/B,KAAA,EAAgCgC,YAAA,KAAiB;EAChD,MAAM;IAAE0F,UAAA;IAAYC,IAAA,EAAMC,QAAA;IAAUC,WAAA;IAAaC,YAAA;IAAc,GAAGC;EAAW,IAAI/H,KAAA;EACjF,MAAM,CAAC2H,IAAA,GAAO,MAAMK,OAAO,IAAI/I,oBAAA,CAAqB;IAClDgJ,IAAA,EAAML,QAAA;IACNM,WAAA,EAAaL,WAAA;IACbM,QAAA,EAAUL;EACZ,CAAC;EACD,OACE,eAAAzI,GAAA,CAACR,QAAA;IAASuJ,OAAA,EAASV,UAAA,IAAcC,IAAA;IAC/BrH,QAAA,iBAAAjB,GAAA,CAACgJ,SAAA;MACCV,IAAA;MACC,GAAGI,UAAA;MACJvF,GAAA,EAAKR,YAAA;MACLsG,OAAA,EAASA,CAAA,KAAMN,OAAA,CAAQ,KAAK;MAC5BO,OAAA,EAASvJ,cAAA,CAAegB,KAAA,CAAMuI,OAAO;MACrCC,QAAA,EAAUxJ,cAAA,CAAegB,KAAA,CAAMwI,QAAQ;MACvCC,YAAA,EAAclK,oBAAA,CAAqByB,KAAA,CAAMyI,YAAA,EAAezF,KAAA,IAAU;QAChEA,KAAA,CAAM0F,aAAA,CAAcC,YAAA,CAAa,cAAc,OAAO;MACxD,CAAC;MACDC,WAAA,EAAarK,oBAAA,CAAqByB,KAAA,CAAM4I,WAAA,EAAc5F,KAAA,IAAU;QAC9D,MAAM;UAAE6F,CAAA;UAAGC;QAAE,IAAI9F,KAAA,CAAM+F,MAAA,CAAOC,KAAA;QAC9BhG,KAAA,CAAM0F,aAAA,CAAcC,YAAA,CAAa,cAAc,MAAM;QACrD3F,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAMyC,WAAA,CAAY,8BAA8B,GAAGJ,CAAC,IAAI;QAC5E7F,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAMyC,WAAA,CAAY,8BAA8B,GAAGH,CAAC,IAAI;MAC9E,CAAC;MACDI,aAAA,EAAe3K,oBAAA,CAAqByB,KAAA,CAAMkJ,aAAA,EAAgBlG,KAAA,IAAU;QAClEA,KAAA,CAAM0F,aAAA,CAAcC,YAAA,CAAa,cAAc,QAAQ;QACvD3F,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAM2C,cAAA,CAAe,4BAA4B;QACrEnG,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAM2C,cAAA,CAAe,4BAA4B;QACrEnG,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAM2C,cAAA,CAAe,2BAA2B;QACpEnG,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAM2C,cAAA,CAAe,2BAA2B;MACtE,CAAC;MACDC,UAAA,EAAY7K,oBAAA,CAAqByB,KAAA,CAAMoJ,UAAA,EAAapG,KAAA,IAAU;QAC5D,MAAM;UAAE6F,CAAA;UAAGC;QAAE,IAAI9F,KAAA,CAAM+F,MAAA,CAAOC,KAAA;QAC9BhG,KAAA,CAAM0F,aAAA,CAAcC,YAAA,CAAa,cAAc,KAAK;QACpD3F,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAM2C,cAAA,CAAe,4BAA4B;QACrEnG,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAM2C,cAAA,CAAe,4BAA4B;QACrEnG,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAMyC,WAAA,CAAY,6BAA6B,GAAGJ,CAAC,IAAI;QAC3E7F,KAAA,CAAM0F,aAAA,CAAclC,KAAA,CAAMyC,WAAA,CAAY,6BAA6B,GAAGH,CAAC,IAAI;QAC3Ed,OAAA,CAAQ,KAAK;MACf,CAAC;IAAA,CACH;EAAA,CACF;AAEJ,CACF;AAEAP,KAAA,CAAMhG,WAAA,GAAc2F,UAAA;AASpB,IAAM,CAACiC,wBAAA,EAA0BC,0BAA0B,IAAI3J,kBAAA,CAAmByH,UAAA,EAAY;EAC5FkB,QAAA,EAAU,CAAC;AACb,CAAC;AAsBD,IAAMD,SAAA,GAAkBhK,KAAA,CAAA0D,UAAA,CACtB,CAAC/B,KAAA,EAAoCgC,YAAA,KAAiB;EACpD,MAAM;IACJ/B,YAAA;IACAsJ,IAAA,GAAO;IACPpJ,QAAA,EAAUqJ,YAAA;IACV7B,IAAA;IACAW,OAAA;IACAmB,eAAA;IACAlB,OAAA;IACAC,QAAA;IACAC,YAAA;IACAG,WAAA;IACAM,aAAA;IACAE,UAAA;IACA,GAAGrB;EACL,IAAI/H,KAAA;EACJ,MAAMmC,OAAA,GAAUrC,uBAAA,CAAwBsH,UAAA,EAAYnH,YAAY;EAChE,MAAM,CAACyJ,IAAA,EAAMC,OAAO,IAAUtL,KAAA,CAAAoC,QAAA,CAAkC,IAAI;EACpE,MAAMgC,YAAA,GAAejE,eAAA,CAAgBwD,YAAA,EAAe4H,KAAA,IAASD,OAAA,CAAQC,KAAI,CAAC;EAC1E,MAAMC,eAAA,GAAwBxL,KAAA,CAAAwC,MAAA,CAAwC,IAAI;EAC1E,MAAMiJ,aAAA,GAAsBzL,KAAA,CAAAwC,MAAA,CAAwC,IAAI;EACxE,MAAMV,QAAA,GAAWqJ,YAAA,IAAgBrH,OAAA,CAAQhC,QAAA;EACzC,MAAM4J,sBAAA,GAA+B1L,KAAA,CAAAwC,MAAA,CAAO,CAAC;EAC7C,MAAMmJ,0BAAA,GAAmC3L,KAAA,CAAAwC,MAAA,CAAOV,QAAQ;EACxD,MAAM8J,aAAA,GAAsB5L,KAAA,CAAAwC,MAAA,CAAO,CAAC;EACpC,MAAM;IAAEQ,UAAA;IAAYG;EAAc,IAAIW,OAAA;EACtC,MAAM+H,WAAA,GAAclL,cAAA,CAAe,MAAM;IAGvC,MAAMmL,cAAA,GAAiBT,IAAA,EAAMvF,QAAA,CAASZ,QAAA,CAASgB,aAAa;IAC5D,IAAI4F,cAAA,EAAgBhI,OAAA,CAAQ5B,QAAA,EAAU+C,KAAA,CAAM;IAC5CgF,OAAA,CAAQ;EACV,CAAC;EAED,MAAM8B,UAAA,GAAmB/L,KAAA,CAAAiD,WAAA,CACtB+I,SAAA,IAAqB;IACpB,IAAI,CAACA,SAAA,IAAYA,SAAA,KAAaC,QAAA,EAAU;IACxC9F,MAAA,CAAO+F,YAAA,CAAaN,aAAA,CAAc5G,OAAO;IACzC0G,sBAAA,CAAuB1G,OAAA,IAAU,mBAAImH,IAAA,CAAK,GAAEC,OAAA,CAAQ;IACpDR,aAAA,CAAc5G,OAAA,GAAUmB,MAAA,CAAOkG,UAAA,CAAWR,WAAA,EAAaG,SAAQ;EACjE,GACA,CAACH,WAAW,CACd;EAEM7L,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpB,MAAMvC,QAAA,GAAW4B,OAAA,CAAQ5B,QAAA;IACzB,IAAIA,QAAA,EAAU;MACZ,MAAMwD,YAAA,GAAeA,CAAA,KAAM;QACzBqG,UAAA,CAAWJ,0BAAA,CAA2B3G,OAAO;QAC7CmF,QAAA,GAAW;MACb;MACA,MAAM7E,WAAA,GAAcA,CAAA,KAAM;QACxB,MAAMgH,WAAA,IAAc,mBAAIH,IAAA,CAAK,GAAEC,OAAA,CAAQ,IAAIV,sBAAA,CAAuB1G,OAAA;QAClE2G,0BAAA,CAA2B3G,OAAA,GAAU2G,0BAAA,CAA2B3G,OAAA,GAAUsH,WAAA;QAC1EnG,MAAA,CAAO+F,YAAA,CAAaN,aAAA,CAAc5G,OAAO;QACzCkF,OAAA,GAAU;MACZ;MACAhI,QAAA,CAASiD,gBAAA,CAAiB5B,cAAA,EAAgB+B,WAAW;MACrDpD,QAAA,CAASiD,gBAAA,CAAiB3B,eAAA,EAAiBkC,YAAY;MACvD,OAAO,MAAM;QACXxD,QAAA,CAASkD,mBAAA,CAAoB7B,cAAA,EAAgB+B,WAAW;QACxDpD,QAAA,CAASkD,mBAAA,CAAoB5B,eAAA,EAAiBkC,YAAY;MAC5D;IACF;EACF,GAAG,CAAC5B,OAAA,CAAQ5B,QAAA,EAAUJ,QAAA,EAAUoI,OAAA,EAASC,QAAA,EAAU4B,UAAU,CAAC;EAKxD/L,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpB,IAAI6E,IAAA,IAAQ,CAACxF,OAAA,CAAQrB,gBAAA,CAAiBuC,OAAA,EAAS+G,UAAA,CAAWjK,QAAQ;EACpE,GAAG,CAACwH,IAAA,EAAMxH,QAAA,EAAUgC,OAAA,CAAQrB,gBAAA,EAAkBsJ,UAAU,CAAC;EAEnD/L,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpBzB,UAAA,CAAW;IACX,OAAO,MAAMG,aAAA,CAAc;EAC7B,GAAG,CAACH,UAAA,EAAYG,aAAa,CAAC;EAE9B,MAAMoJ,mBAAA,GAA4BvM,KAAA,CAAAwM,OAAA,CAAQ,MAAM;IAC9C,OAAOnB,IAAA,GAAOoB,sBAAA,CAAuBpB,IAAI,IAAI;EAC/C,GAAG,CAACA,IAAI,CAAC;EAET,IAAI,CAACvH,OAAA,CAAQ5B,QAAA,EAAU,OAAO;EAE9B,OACE,eAAAjB,IAAA,CAAAF,QAAA;IACGkB,QAAA,GAAAsK,mBAAA,IACC,eAAAvL,GAAA,CAAC0L,aAAA;MACC9K,YAAA;MAEAqG,IAAA,EAAK;MACL,aAAWiD,IAAA,KAAS,eAAe,cAAc;MACjD,eAAW;MAEVjJ,QAAA,EAAAsK;IAAA,CACH,GAGF,eAAAvL,GAAA,CAACgK,wBAAA;MAAyBlI,KAAA,EAAOlB,YAAA;MAAcqI,OAAA,EAAS4B,WAAA;MACrD5J,QAAA,EAAShC,QAAA,CAAA0M,YAAA,CACR,eAAA3L,GAAA,CAACG,UAAA,CAAWyL,QAAA,EAAX;QAAoB9J,KAAA,EAAOlB,YAAA;QAC1BK,QAAA,iBAAAjB,GAAA,CAAkBV,gBAAA,CAAAuM,IAAA,EAAjB;UACCC,OAAA,EAAO;UACP1B,eAAA,EAAiBlL,oBAAA,CAAqBkL,eAAA,EAAiB,MAAM;YAC3D,IAAI,CAACtH,OAAA,CAAQvB,8BAAA,CAA+ByC,OAAA,EAAS6G,WAAA,CAAY;YACjE/H,OAAA,CAAQvB,8BAAA,CAA+ByC,OAAA,GAAU;UACnD,CAAC;UAED/C,QAAA,iBAAAjB,GAAA,CAACP,SAAA,CAAUsM,EAAA,EAAV;YAEC9E,IAAA,EAAK;YACL,aAAU;YACV,eAAW;YACXC,QAAA,EAAU;YACV,cAAYoB,IAAA,GAAO,SAAS;YAC5B,wBAAsBxF,OAAA,CAAQ/B,cAAA;YAC7B,GAAG2H,UAAA;YACJvF,GAAA,EAAKC,YAAA;YACL+D,KAAA,EAAO;cAAE6E,UAAA,EAAY;cAAQC,WAAA,EAAa;cAAQ,GAAGtL,KAAA,CAAMwG;YAAM;YACjE+E,SAAA,EAAWhN,oBAAA,CAAqByB,KAAA,CAAMuL,SAAA,EAAYvI,KAAA,IAAU;cAC1D,IAAIA,KAAA,CAAMG,GAAA,KAAQ,UAAU;cAC5BsG,eAAA,GAAkBzG,KAAA,CAAMwI,WAAW;cACnC,IAAI,CAACxI,KAAA,CAAMwI,WAAA,CAAYC,gBAAA,EAAkB;gBACvCtJ,OAAA,CAAQvB,8BAAA,CAA+ByC,OAAA,GAAU;gBACjD6G,WAAA,CAAY;cACd;YACF,CAAC;YACDwB,aAAA,EAAenN,oBAAA,CAAqByB,KAAA,CAAM0L,aAAA,EAAgB1I,KAAA,IAAU;cAClE,IAAIA,KAAA,CAAM2I,MAAA,KAAW,GAAG;cACxB9B,eAAA,CAAgBxG,OAAA,GAAU;gBAAEwF,CAAA,EAAG7F,KAAA,CAAM4I,OAAA;gBAAS9C,CAAA,EAAG9F,KAAA,CAAM6I;cAAQ;YACjE,CAAC;YACDC,aAAA,EAAevN,oBAAA,CAAqByB,KAAA,CAAM8L,aAAA,EAAgB9I,KAAA,IAAU;cAClE,IAAI,CAAC6G,eAAA,CAAgBxG,OAAA,EAAS;cAC9B,MAAMwF,CAAA,GAAI7F,KAAA,CAAM4I,OAAA,GAAU/B,eAAA,CAAgBxG,OAAA,CAAQwF,CAAA;cAClD,MAAMC,CAAA,GAAI9F,KAAA,CAAM6I,OAAA,GAAUhC,eAAA,CAAgBxG,OAAA,CAAQyF,CAAA;cAClD,MAAMiD,mBAAA,GAAsBC,OAAA,CAAQlC,aAAA,CAAczG,OAAO;cACzD,MAAM4I,iBAAA,GAAoB,CAAC,QAAQ,OAAO,EAAEC,QAAA,CAAS/J,OAAA,CAAQ/B,cAAc;cAC3E,MAAM+L,KAAA,GAAQ,CAAC,QAAQ,IAAI,EAAED,QAAA,CAAS/J,OAAA,CAAQ/B,cAAc,IACxDgM,IAAA,CAAKC,GAAA,GACLD,IAAA,CAAKE,GAAA;cACT,MAAMC,QAAA,GAAWN,iBAAA,GAAoBE,KAAA,CAAM,GAAGtD,CAAC,IAAI;cACnD,MAAM2D,QAAA,GAAW,CAACP,iBAAA,GAAoBE,KAAA,CAAM,GAAGrD,CAAC,IAAI;cACpD,MAAM2D,eAAA,GAAkBzJ,KAAA,CAAM0J,WAAA,KAAgB,UAAU,KAAK;cAC7D,MAAM1D,KAAA,GAAQ;gBAAEH,CAAA,EAAG0D,QAAA;gBAAUzD,CAAA,EAAG0D;cAAS;cACzC,MAAMG,WAAA,GAAc;gBAAEC,aAAA,EAAe5J,KAAA;gBAAOgG;cAAM;cAClD,IAAI+C,mBAAA,EAAqB;gBACvBjC,aAAA,CAAczG,OAAA,GAAU2F,KAAA;gBACxB6D,4BAAA,CAA6BvF,gBAAA,EAAkBsB,WAAA,EAAa+D,WAAA,EAAa;kBACvEG,QAAA,EAAU;gBACZ,CAAC;cACH,WAAWC,kBAAA,CAAmB/D,KAAA,EAAO7G,OAAA,CAAQ/B,cAAA,EAAgBqM,eAAe,GAAG;gBAC7E3C,aAAA,CAAczG,OAAA,GAAU2F,KAAA;gBACxB6D,4BAAA,CAA6BxF,iBAAA,EAAmBoB,YAAA,EAAckE,WAAA,EAAa;kBACzEG,QAAA,EAAU;gBACZ,CAAC;gBACA9J,KAAA,CAAM6C,MAAA,CAAuBmH,iBAAA,CAAkBhK,KAAA,CAAMiK,SAAS;cACjE,WAAWb,IAAA,CAAKc,GAAA,CAAIrE,CAAC,IAAI4D,eAAA,IAAmBL,IAAA,CAAKc,GAAA,CAAIpE,CAAC,IAAI2D,eAAA,EAAiB;gBAGzE5C,eAAA,CAAgBxG,OAAA,GAAU;cAC5B;YACF,CAAC;YACD8J,WAAA,EAAa5O,oBAAA,CAAqByB,KAAA,CAAMmN,WAAA,EAAcnK,KAAA,IAAU;cAC9D,MAAMgG,KAAA,GAAQc,aAAA,CAAczG,OAAA;cAC5B,MAAMwC,MAAA,GAAS7C,KAAA,CAAM6C,MAAA;cACrB,IAAIA,MAAA,CAAOuH,iBAAA,CAAkBpK,KAAA,CAAMiK,SAAS,GAAG;gBAC7CpH,MAAA,CAAOwH,qBAAA,CAAsBrK,KAAA,CAAMiK,SAAS;cAC9C;cACAnD,aAAA,CAAczG,OAAA,GAAU;cACxBwG,eAAA,CAAgBxG,OAAA,GAAU;cAC1B,IAAI2F,KAAA,EAAO;gBACT,MAAMsE,KAAA,GAAQtK,KAAA,CAAM0F,aAAA;gBACpB,MAAMiE,WAAA,GAAc;kBAAEC,aAAA,EAAe5J,KAAA;kBAAOgG;gBAAM;gBAClD,IACE+D,kBAAA,CAAmB/D,KAAA,EAAO7G,OAAA,CAAQ/B,cAAA,EAAgB+B,OAAA,CAAQ9B,cAAc,GACxE;kBACAwM,4BAAA,CAA6BrF,eAAA,EAAiB4B,UAAA,EAAYuD,WAAA,EAAa;oBACrEG,QAAA,EAAU;kBACZ,CAAC;gBACH,OAAO;kBACLD,4BAAA,CACEtF,kBAAA,EACA2B,aAAA,EACAyD,WAAA,EACA;oBACEG,QAAA,EAAU;kBACZ,CACF;gBACF;gBAGAQ,KAAA,CAAM9J,gBAAA,CAAiB,SAAU+J,MAAA,IAAUA,MAAA,CAAMnH,cAAA,CAAe,GAAG;kBACjEoH,IAAA,EAAM;gBACR,CAAC;cACH;YACF,CAAC;UAAA,CACH;QAAA,CACF;MAAA,CACF,GACArL,OAAA,CAAQ5B,QACV;IAAA,CACF;EAAA,CACF;AAEJ,CACF;AAQA,IAAMwK,aAAA,GAA+C/K,KAAA,IAA2C;EAC9F,MAAM;IAAEC,YAAA;IAAcK,QAAA;IAAU,GAAGmN;EAAc,IAAIzN,KAAA;EACrD,MAAMmC,OAAA,GAAUrC,uBAAA,CAAwBsH,UAAA,EAAYnH,YAAY;EAChE,MAAM,CAACyN,kBAAA,EAAoBC,qBAAqB,IAAUtP,KAAA,CAAAoC,QAAA,CAAS,KAAK;EACxE,MAAM,CAACmN,WAAA,EAAaC,cAAc,IAAUxP,KAAA,CAAAoC,QAAA,CAAS,KAAK;EAG1DqN,YAAA,CAAa,MAAMH,qBAAA,CAAsB,IAAI,CAAC;EAGxCtP,KAAA,CAAAyE,SAAA,CAAU,MAAM;IACpB,MAAMiL,KAAA,GAAQvJ,MAAA,CAAOkG,UAAA,CAAW,MAAMmD,cAAA,CAAe,IAAI,GAAG,GAAI;IAChE,OAAO,MAAMrJ,MAAA,CAAO+F,YAAA,CAAawD,KAAK;EACxC,GAAG,EAAE;EAEL,OAAOH,WAAA,GAAc,OACnB,eAAAvO,GAAA,CAACT,MAAA;IAAOuM,OAAA,EAAO;IACb7K,QAAA,iBAAAjB,GAAA,CAACF,cAAA;MAAgB,GAAGsO,aAAA;MACjBnN,QAAA,EAAAoN,kBAAA,IACC,eAAApO,IAAA,CAAAF,QAAA;QACGkB,QAAA,GAAA6B,OAAA,CAAQjC,KAAA,EAAM,KAAEI,QAAA;MAAA,CACnB;IAAA,CAEJ;EAAA,CACF;AAEJ;AAMA,IAAM0N,UAAA,GAAa;AAMnB,IAAMC,UAAA,GAAmB5P,KAAA,CAAA0D,UAAA,CACvB,CAAC/B,KAAA,EAAqCgC,YAAA,KAAiB;EACrD,MAAM;IAAE/B,YAAA;IAAc,GAAGiO;EAAW,IAAIlO,KAAA;EACxC,OAAO,eAAAX,GAAA,CAACP,SAAA,CAAUqP,GAAA,EAAV;IAAe,GAAGD,UAAA;IAAY1L,GAAA,EAAKR;EAAA,CAAc;AAC3D,CACF;AAEAiM,UAAA,CAAWxM,WAAA,GAAcuM,UAAA;AAMzB,IAAMI,gBAAA,GAAmB;AAKzB,IAAMC,gBAAA,GAAyBhQ,KAAA,CAAA0D,UAAA,CAC7B,CAAC/B,KAAA,EAA2CgC,YAAA,KAAiB;EAC3D,MAAM;IAAE/B,YAAA;IAAc,GAAGqO;EAAiB,IAAItO,KAAA;EAC9C,OAAO,eAAAX,GAAA,CAACP,SAAA,CAAUqP,GAAA,EAAV;IAAe,GAAGG,gBAAA;IAAkB9L,GAAA,EAAKR;EAAA,CAAc;AACjE,CACF;AAEAqM,gBAAA,CAAiB5M,WAAA,GAAc2M,gBAAA;AAM/B,IAAMG,WAAA,GAAc;AAapB,IAAMC,WAAA,GAAoBnQ,KAAA,CAAA0D,UAAA,CACxB,CAAC/B,KAAA,EAAsCgC,YAAA,KAAiB;EACtD,MAAM;IAAEyM,OAAA;IAAS,GAAGC;EAAY,IAAI1O,KAAA;EAEpC,IAAI,CAACyO,OAAA,CAAQ1N,IAAA,CAAK,GAAG;IACnBC,OAAA,CAAQC,KAAA,CACN,0CAA0CsN,WAAW,oCACvD;IACA,OAAO;EACT;EAEA,OACE,eAAAlP,GAAA,CAACsP,oBAAA;IAAqBF,OAAA;IAAkBtD,OAAA,EAAO;IAC7C7K,QAAA,iBAAAjB,GAAA,CAACuP,UAAA;MAAY,GAAGF,WAAA;MAAalM,GAAA,EAAKR;IAAA,CAAc;EAAA,CAClD;AAEJ,CACF;AAEAwM,WAAA,CAAY/M,WAAA,GAAc8M,WAAA;AAM1B,IAAMM,UAAA,GAAa;AAMnB,IAAMD,UAAA,GAAmBvQ,KAAA,CAAA0D,UAAA,CACvB,CAAC/B,KAAA,EAAqCgC,YAAA,KAAiB;EACrD,MAAM;IAAE/B,YAAA;IAAc,GAAG6O;EAAW,IAAI9O,KAAA;EACxC,MAAM+O,kBAAA,GAAqBzF,0BAAA,CAA2BuF,UAAA,EAAY5O,YAAY;EAE9E,OACE,eAAAZ,GAAA,CAACsP,oBAAA;IAAqBxD,OAAA,EAAO;IAC3B7K,QAAA,iBAAAjB,GAAA,CAACP,SAAA,CAAU6M,MAAA,EAAV;MACCpC,IAAA,EAAK;MACJ,GAAGuF,UAAA;MACJtM,GAAA,EAAKR,YAAA;MACLgN,OAAA,EAASzQ,oBAAA,CAAqByB,KAAA,CAAMgP,OAAA,EAASD,kBAAA,CAAmBzG,OAAO;IAAA,CACzE;EAAA,CACF;AAEJ,CACF;AAEAsG,UAAA,CAAWnN,WAAA,GAAcoN,UAAA;AASzB,IAAMF,oBAAA,GAA6BtQ,KAAA,CAAA0D,UAAA,CAGjC,CAAC/B,KAAA,EAA+CgC,YAAA,KAAiB;EACjE,MAAM;IAAE/B,YAAA;IAAcwO,OAAA;IAAS,GAAGQ;EAAqB,IAAIjP,KAAA;EAE3D,OACE,eAAAX,GAAA,CAACP,SAAA,CAAUqP,GAAA,EAAV;IACC,qCAAkC;IAClC,iCAA+BM,OAAA,IAAW;IACzC,GAAGQ,oBAAA;IACJzM,GAAA,EAAKR;EAAA,CACP;AAEJ,CAAC;AAED,SAAS8I,uBAAuBoE,SAAA,EAAwB;EACtD,MAAMC,WAAA,GAAwB,EAAC;EAC/B,MAAMC,UAAA,GAAaC,KAAA,CAAMC,IAAA,CAAKJ,SAAA,CAAUE,UAAU;EAElDA,UAAA,CAAWG,OAAA,CAAS7F,IAAA,IAAS;IAC3B,IAAIA,IAAA,CAAK8F,QAAA,KAAa9F,IAAA,CAAK+F,SAAA,IAAa/F,IAAA,CAAKyF,WAAA,EAAaA,WAAA,CAAYO,IAAA,CAAKhG,IAAA,CAAKyF,WAAW;IAC3F,IAAIQ,aAAA,CAAcjG,IAAI,GAAG;MACvB,MAAMkG,QAAA,GAAWlG,IAAA,CAAKmG,UAAA,IAAcnG,IAAA,CAAKoG,MAAA,IAAUpG,IAAA,CAAKlD,KAAA,CAAMuJ,OAAA,KAAY;MAC1E,MAAMC,UAAA,GAAatG,IAAA,CAAKuG,OAAA,CAAQC,yBAAA,KAA8B;MAE9D,IAAI,CAACN,QAAA,EAAU;QACb,IAAII,UAAA,EAAY;UACd,MAAMvB,OAAA,GAAU/E,IAAA,CAAKuG,OAAA,CAAQE,qBAAA;UAC7B,IAAI1B,OAAA,EAASU,WAAA,CAAYO,IAAA,CAAKjB,OAAO;QACvC,OAAO;UACLU,WAAA,CAAYO,IAAA,CAAK,GAAG5E,sBAAA,CAAuBpB,IAAI,CAAC;QAClD;MACF;IACF;EACF,CAAC;EAID,OAAOyF,WAAA;AACT;AAIA,SAAStC,6BAIPuD,IAAA,EACAC,OAAA,EACAtH,MAAA,EACA;EAAE+D;AAAS,GACX;EACA,MAAMpE,aAAA,GAAgBK,MAAA,CAAO6D,aAAA,CAAclE,aAAA;EAC3C,MAAM1F,KAAA,GAAQ,IAAIa,WAAA,CAAYuM,IAAA,EAAM;IAAEE,OAAA,EAAS;IAAMC,UAAA,EAAY;IAAMxH;EAAO,CAAC;EAC/E,IAAIsH,OAAA,EAAS3H,aAAA,CAAclF,gBAAA,CAAiB4M,IAAA,EAAMC,OAAA,EAA0B;IAAE7C,IAAA,EAAM;EAAK,CAAC;EAE1F,IAAIV,QAAA,EAAU;IACZ/N,2BAAA,CAA4B2J,aAAA,EAAe1F,KAAK;EAClD,OAAO;IACL0F,aAAA,CAAc5E,aAAA,CAAcd,KAAK;EACnC;AACF;AAEA,IAAM+J,kBAAA,GAAqBA,CACzB/D,KAAA,EACAwH,SAAA,EACAC,SAAA,GAAY,MACT;EACH,MAAMC,MAAA,GAAStE,IAAA,CAAKc,GAAA,CAAIlE,KAAA,CAAMH,CAAC;EAC/B,MAAM8H,MAAA,GAASvE,IAAA,CAAKc,GAAA,CAAIlE,KAAA,CAAMF,CAAC;EAC/B,MAAM8H,QAAA,GAAWF,MAAA,GAASC,MAAA;EAC1B,IAAIH,SAAA,KAAc,UAAUA,SAAA,KAAc,SAAS;IACjD,OAAOI,QAAA,IAAYF,MAAA,GAASD,SAAA;EAC9B,OAAO;IACL,OAAO,CAACG,QAAA,IAAYD,MAAA,GAASF,SAAA;EAC/B;AACF;AAEA,SAAS3C,aAAa+C,QAAA,GAAWA,CAAA,KAAM,CAAC,GAAG;EACzC,MAAMC,EAAA,GAAK9R,cAAA,CAAe6R,QAAQ;EAClC3R,eAAA,CAAgB,MAAM;IACpB,IAAI6R,IAAA,GAAO;IACX,IAAIC,IAAA,GAAO;IACXD,IAAA,GAAOvM,MAAA,CAAOyM,qBAAA,CAAsB,MAAOD,IAAA,GAAOxM,MAAA,CAAOyM,qBAAA,CAAsBH,EAAE,CAAE;IACnF,OAAO,MAAM;MACXtM,MAAA,CAAO0M,oBAAA,CAAqBH,IAAI;MAChCvM,MAAA,CAAO0M,oBAAA,CAAqBF,IAAI;IAClC;EACF,GAAG,CAACF,EAAE,CAAC;AACT;AAEA,SAASnB,cAAcjG,IAAA,EAAgC;EACrD,OAAOA,IAAA,CAAK8F,QAAA,KAAa9F,IAAA,CAAKyH,YAAA;AAChC;AAYA,SAASlM,sBAAsBiK,SAAA,EAAwB;EACrD,MAAMkC,KAAA,GAAuB,EAAC;EAC9B,MAAMC,MAAA,GAAS9N,QAAA,CAAS+N,gBAAA,CAAiBpC,SAAA,EAAWqC,UAAA,CAAWC,YAAA,EAAc;IAC3EC,UAAA,EAAa/H,IAAA,IAAc;MACzB,MAAMgI,aAAA,GAAgBhI,IAAA,CAAKiI,OAAA,KAAY,WAAWjI,IAAA,CAAKH,IAAA,KAAS;MAChE,IAAIG,IAAA,CAAKkI,QAAA,IAAYlI,IAAA,CAAKoG,MAAA,IAAU4B,aAAA,EAAe,OAAOH,UAAA,CAAWM,WAAA;MAIrE,OAAOnI,IAAA,CAAKnD,QAAA,IAAY,IAAIgL,UAAA,CAAWO,aAAA,GAAgBP,UAAA,CAAWM,WAAA;IACpE;EACF,CAAC;EACD,OAAOR,MAAA,CAAOU,QAAA,CAAS,GAAGX,KAAA,CAAM1B,IAAA,CAAK2B,MAAA,CAAOW,WAA0B;EAGtE,OAAOZ,KAAA;AACT;AAEA,SAASlL,WAAW+L,UAAA,EAA2B;EAC7C,MAAMC,wBAAA,GAA2B3O,QAAA,CAASgB,aAAA;EAC1C,OAAO0N,UAAA,CAAWE,IAAA,CAAMlM,SAAA,IAAc;IAEpC,IAAIA,SAAA,KAAciM,wBAAA,EAA0B,OAAO;IACnDjM,SAAA,CAAU3C,KAAA,CAAM;IAChB,OAAOC,QAAA,CAASgB,aAAA,KAAkB2N,wBAAA;EACpC,CAAC;AACH;AAEA,IAAMhR,QAAA,GAAWnB,aAAA;AACjB,IAAMqS,QAAA,GAAWtQ,aAAA;AACjB,IAAMuQ,KAAA,GAAO5K,KAAA;AACb,IAAM6K,KAAA,GAAQrE,UAAA;AACd,IAAMsE,WAAA,GAAclE,gBAAA;AACpB,IAAMmE,MAAA,GAAShE,WAAA;AACf,IAAMiE,KAAA,GAAQ7D,UAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}