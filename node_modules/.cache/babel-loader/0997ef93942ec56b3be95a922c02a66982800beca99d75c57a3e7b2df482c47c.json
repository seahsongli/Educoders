{"ast":null,"code":"import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, {\n  confirmations = 1,\n  hash,\n  onReplaced,\n  pollingInterval = client.pollingInterval,\n  retryCount = 6,\n  retryDelay = ({\n    count\n  }) => ~~(1 << count) * 200,\n  // exponential backoff\n  timeout\n}) {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  let count = 0;\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  return new Promise((resolve, reject) => {\n    if (timeout) setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({\n      hash\n    })), timeout);\n    const _unobserve = observe(observerId, {\n      onReplaced,\n      resolve,\n      reject\n    }, emit => {\n      const _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          const done = fn => {\n            _unwatch();\n            fn();\n            _unobserve();\n          };\n          let blockNumber = blockNumber_;\n          if (retrying) return;\n          if (count > retryCount) done(() => emit.reject(new WaitForTransactionReceiptTimeoutError({\n            hash\n          })));\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              done(() => emit.resolve(receipt));\n              return;\n            }\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (!transaction) {\n              retrying = true;\n              await withRetry(async () => {\n                transaction = await getAction(client, getTransaction, 'getTransaction')({\n                  hash\n                });\n                if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n              }, {\n                delay: retryDelay,\n                retryCount\n              });\n              retrying = false;\n            }\n            // Get the receipt to check if it's been processed.\n            receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n              hash\n            });\n            // Check if we have enough confirmations. If not, continue polling.\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {\n              if (!transaction) {\n                retrying = false;\n                return;\n              }\n              try {\n                replacedTransaction = transaction;\n                // Let's retrieve the transactions from the current block.\n                // We need to retry as some RPC Providers may be slow to sync\n                // up mined blocks.\n                retrying = true;\n                const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                  blockNumber,\n                  includeTransactions: true\n                }), {\n                  delay: retryDelay,\n                  retryCount,\n                  shouldRetry: ({\n                    error\n                  }) => error instanceof BlockNotFoundError\n                });\n                retrying = false;\n                const replacementTransaction = block.transactions.find(({\n                  from,\n                  nonce\n                }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return;\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                  hash: replacementTransaction.hash\n                });\n                // Check if we have enough confirmations. If not, continue polling.\n                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n                let reason = 'replaced';\n                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {\n                  reason = 'repriced';\n                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                  reason = 'cancelled';\n                }\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt\n                  });\n                  emit.resolve(receipt);\n                });\n              } catch (err_) {\n                done(() => emit.reject(err_));\n              }\n            } else {\n              done(() => emit.reject(err));\n            }\n          } finally {\n            count++;\n          }\n        }\n      });\n    });\n  });\n}","map":{"version":3,"names":["BlockNotFoundError","TransactionNotFoundError","TransactionReceiptNotFoundError","WaitForTransactionReceiptTimeoutError","getAction","observe","withRetry","stringify","getBlock","getTransaction","getTransactionReceipt","watchBlockNumber","waitForTransactionReceipt","client","confirmations","hash","onReplaced","pollingInterval","retryCount","retryDelay","count","timeout","observerId","uid","transaction","replacedTransaction","receipt","retrying","Promise","resolve","reject","setTimeout","_unobserve","emit","_unwatch","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","done","fn","blockNumber","delay","err","block","includeTransactions","shouldRetry","error","replacementTransaction","transactions","find","from","nonce","reason","to","value","transactionReceipt","err_"],"sources":["C:\\Users\\seahs\\repos\\worldcoin-app\\node_modules\\@worldcoin\\idkit-core\\node_modules\\viem\\actions\\public\\waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<chain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<chain>\n\nexport type WaitForTransactionReceiptParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number | undefined\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: ((response: ReplacementReturnType<chain>) => void) | undefined\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the transaction or block is not found.\n   * @default 6 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /** Optional timeout (in milliseconds) to wait before stopping polling. */\n  timeout?: number | undefined\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    retryCount = 6,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout,\n  }: WaitForTransactionReceiptParameters<chain>,\n): Promise<WaitForTransactionReceiptReturnType<chain>> {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  let count = 0\n  let transaction: GetTransactionReturnType<chain> | undefined\n  let replacedTransaction: GetTransactionReturnType<chain> | undefined\n  let receipt: GetTransactionReceiptReturnType<chain>\n  let retrying = false\n\n  return new Promise((resolve, reject) => {\n    if (timeout)\n      setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n\n    const _unobserve = observe(\n      observerId,\n      { onReplaced, resolve, reject },\n      (emit) => {\n        const _unwatch = getAction(\n          client,\n          watchBlockNumber,\n          'watchBlockNumber',\n        )({\n          emitMissed: true,\n          emitOnBegin: true,\n          poll: true,\n          pollingInterval,\n          async onBlockNumber(blockNumber_) {\n            const done = (fn: () => void) => {\n              _unwatch()\n              fn()\n              _unobserve()\n            }\n\n            let blockNumber = blockNumber_\n\n            if (retrying) return\n            if (count > retryCount)\n              done(() =>\n                emit.reject(\n                  new WaitForTransactionReceiptTimeoutError({ hash }),\n                ),\n              )\n\n            try {\n              // If we already have a valid receipt, let's check if we have enough\n              // confirmations. If we do, then we can resolve.\n              if (receipt) {\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                done(() => emit.resolve(receipt))\n                return\n              }\n\n              // Get the transaction to check if it's been replaced.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined transactions.\n              if (!transaction) {\n                retrying = true\n                await withRetry(\n                  async () => {\n                    transaction = (await getAction(\n                      client,\n                      getTransaction,\n                      'getTransaction',\n                    )({ hash })) as GetTransactionReturnType<chain>\n                    if (transaction.blockNumber)\n                      blockNumber = transaction.blockNumber\n                  },\n                  {\n                    delay: retryDelay,\n                    retryCount,\n                  },\n                )\n                retrying = false\n              }\n\n              // Get the receipt to check if it's been processed.\n              receipt = await getAction(\n                client,\n                getTransactionReceipt,\n                'getTransactionReceipt',\n              )({ hash })\n\n              // Check if we have enough confirmations. If not, continue polling.\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt))\n            } catch (err) {\n              // If the receipt is not found, the transaction will be pending.\n              // We need to check if it has potentially been replaced.\n              if (\n                err instanceof TransactionNotFoundError ||\n                err instanceof TransactionReceiptNotFoundError\n              ) {\n                if (!transaction) {\n                  retrying = false\n                  return\n                }\n\n                try {\n                  replacedTransaction = transaction\n\n                  // Let's retrieve the transactions from the current block.\n                  // We need to retry as some RPC Providers may be slow to sync\n                  // up mined blocks.\n                  retrying = true\n                  const block = await withRetry(\n                    () =>\n                      getAction(\n                        client,\n                        getBlock,\n                        'getBlock',\n                      )({\n                        blockNumber,\n                        includeTransactions: true,\n                      }),\n                    {\n                      delay: retryDelay,\n                      retryCount,\n                      shouldRetry: ({ error }) =>\n                        error instanceof BlockNotFoundError,\n                    },\n                  )\n                  retrying = false\n\n                  const replacementTransaction = (\n                    block.transactions as {} as Transaction[]\n                  ).find(\n                    ({ from, nonce }) =>\n                      from === replacedTransaction!.from &&\n                      nonce === replacedTransaction!.nonce,\n                  )\n\n                  // If we couldn't find a replacement transaction, continue polling.\n                  if (!replacementTransaction) return\n\n                  // If we found a replacement transaction, return it's receipt.\n                  receipt = await getAction(\n                    client,\n                    getTransactionReceipt,\n                    'getTransactionReceipt',\n                  )({\n                    hash: replacementTransaction.hash,\n                  })\n\n                  // Check if we have enough confirmations. If not, continue polling.\n                  if (\n                    confirmations > 1 &&\n                    (!receipt.blockNumber ||\n                      blockNumber - receipt.blockNumber + 1n < confirmations)\n                  )\n                    return\n\n                  let reason: ReplacementReason = 'replaced'\n                  if (\n                    replacementTransaction.to === replacedTransaction.to &&\n                    replacementTransaction.value === replacedTransaction.value\n                  ) {\n                    reason = 'repriced'\n                  } else if (\n                    replacementTransaction.from === replacementTransaction.to &&\n                    replacementTransaction.value === 0n\n                  ) {\n                    reason = 'cancelled'\n                  }\n\n                  done(() => {\n                    emit.onReplaced?.({\n                      reason,\n                      replacedTransaction: replacedTransaction! as any,\n                      transaction: replacementTransaction,\n                      transactionReceipt: receipt,\n                    })\n                    emit.resolve(receipt)\n                  })\n                } catch (err_) {\n                  done(() => emit.reject(err_))\n                }\n              } else {\n                done(() => emit.reject(err))\n              }\n            } finally {\n              count++\n            }\n          },\n        })\n      },\n    )\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}