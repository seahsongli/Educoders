{"ast":null,"code":"// src/lib/hashing.ts\nimport { Buffer } from \"buffer/index.js\";\nimport { encodePacked, isBytes, isHex, keccak256 } from \"viem\";\nfunction hashToField(input) {\n  if (isBytes(input) || isHex(input)) return hashEncodedBytes(input);\n  return hashString(input);\n}\nfunction packAndEncode(input) {\n  const [types, values] = input.reduce(([types2, values2], [type, value]) => {\n    types2.push(type);\n    values2.push(value);\n    return [types2, values2];\n  }, [[], []]);\n  return hashEncodedBytes(encodePacked(types, values));\n}\nfunction hashString(input) {\n  const bytesInput = Buffer.from(input);\n  return hashEncodedBytes(bytesInput);\n}\nfunction hashEncodedBytes(input) {\n  const hash = BigInt(keccak256(input)) >> 8n;\n  const rawDigest = hash.toString(16);\n  return {\n    hash,\n    digest: `0x${rawDigest.padStart(64, \"0\")}`\n  };\n}\nvar solidityEncode = (types, values) => {\n  if (types.length !== values.length) {\n    throw new Error(\"Types and values arrays must have the same length.\");\n  }\n  return {\n    types,\n    values\n  };\n};\nvar generateSignal = signal => {\n  if (!signal || typeof signal === \"string\") return hashToField(signal ?? \"\");\n  return packAndEncode(signal.types.map((type, index) => [type, signal.values[index]]));\n};\nvar encodeAction = action => {\n  if (!action) return \"\";\n  if (typeof action === \"string\") return action;\n  return action.types.map((type, index) => `${type}(${action.values[index]})`).join(\",\");\n};\nexport { hashToField, packAndEncode, solidityEncode, generateSignal, encodeAction };","map":{"version":3,"names":["Buffer","encodePacked","isBytes","isHex","keccak256","hashToField","input","hashEncodedBytes","hashString","packAndEncode","types","values","reduce","types2","values2","type","value","push","bytesInput","from","hash","BigInt","rawDigest","toString","digest","padStart","solidityEncode","length","Error","generateSignal","signal","map","index","encodeAction","action","join"],"sources":["C:/Users/seahs/repos/worldcoin-app/node_modules/@worldcoin/idkit-core/build/chunk-QN7JTJAQ.js"],"sourcesContent":["// src/lib/hashing.ts\nimport { Buffer } from \"buffer/index.js\";\nimport { encodePacked, isBytes, isHex, keccak256 } from \"viem\";\nfunction hashToField(input) {\n  if (isBytes(input) || isHex(input)) return hashEncodedBytes(input);\n  return hashString(input);\n}\nfunction packAndEncode(input) {\n  const [types, values] = input.reduce(\n    ([types2, values2], [type, value]) => {\n      types2.push(type);\n      values2.push(value);\n      return [types2, values2];\n    },\n    [[], []]\n  );\n  return hashEncodedBytes(encodePacked(types, values));\n}\nfunction hashString(input) {\n  const bytesInput = Buffer.from(input);\n  return hashEncodedBytes(bytesInput);\n}\nfunction hashEncodedBytes(input) {\n  const hash = BigInt(keccak256(input)) >> 8n;\n  const rawDigest = hash.toString(16);\n  return { hash, digest: `0x${rawDigest.padStart(64, \"0\")}` };\n}\nvar solidityEncode = (types, values) => {\n  if (types.length !== values.length) {\n    throw new Error(\"Types and values arrays must have the same length.\");\n  }\n  return { types, values };\n};\nvar generateSignal = (signal) => {\n  if (!signal || typeof signal === \"string\") return hashToField(signal ?? \"\");\n  return packAndEncode(signal.types.map((type, index) => [type, signal.values[index]]));\n};\nvar encodeAction = (action) => {\n  if (!action) return \"\";\n  if (typeof action === \"string\") return action;\n  return action.types.map((type, index) => `${type}(${action.values[index]})`).join(\",\");\n};\n\nexport {\n  hashToField,\n  packAndEncode,\n  solidityEncode,\n  generateSignal,\n  encodeAction\n};\n"],"mappings":"AAAA;AACA,SAASA,MAAM,QAAQ,iBAAiB;AACxC,SAASC,YAAY,EAAEC,OAAO,EAAEC,KAAK,EAAEC,SAAS,QAAQ,MAAM;AAC9D,SAASC,WAAWA,CAACC,KAAK,EAAE;EAC1B,IAAIJ,OAAO,CAACI,KAAK,CAAC,IAAIH,KAAK,CAACG,KAAK,CAAC,EAAE,OAAOC,gBAAgB,CAACD,KAAK,CAAC;EAClE,OAAOE,UAAU,CAACF,KAAK,CAAC;AAC1B;AACA,SAASG,aAAaA,CAACH,KAAK,EAAE;EAC5B,MAAM,CAACI,KAAK,EAAEC,MAAM,CAAC,GAAGL,KAAK,CAACM,MAAM,CAClC,CAAC,CAACC,MAAM,EAAEC,OAAO,CAAC,EAAE,CAACC,IAAI,EAAEC,KAAK,CAAC,KAAK;IACpCH,MAAM,CAACI,IAAI,CAACF,IAAI,CAAC;IACjBD,OAAO,CAACG,IAAI,CAACD,KAAK,CAAC;IACnB,OAAO,CAACH,MAAM,EAAEC,OAAO,CAAC;EAC1B,CAAC,EACD,CAAC,EAAE,EAAE,EAAE,CACT,CAAC;EACD,OAAOP,gBAAgB,CAACN,YAAY,CAACS,KAAK,EAAEC,MAAM,CAAC,CAAC;AACtD;AACA,SAASH,UAAUA,CAACF,KAAK,EAAE;EACzB,MAAMY,UAAU,GAAGlB,MAAM,CAACmB,IAAI,CAACb,KAAK,CAAC;EACrC,OAAOC,gBAAgB,CAACW,UAAU,CAAC;AACrC;AACA,SAASX,gBAAgBA,CAACD,KAAK,EAAE;EAC/B,MAAMc,IAAI,GAAGC,MAAM,CAACjB,SAAS,CAACE,KAAK,CAAC,CAAC,IAAI,EAAE;EAC3C,MAAMgB,SAAS,GAAGF,IAAI,CAACG,QAAQ,CAAC,EAAE,CAAC;EACnC,OAAO;IAAEH,IAAI;IAAEI,MAAM,EAAE,KAAKF,SAAS,CAACG,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;EAAG,CAAC;AAC7D;AACA,IAAIC,cAAc,GAAGA,CAAChB,KAAK,EAAEC,MAAM,KAAK;EACtC,IAAID,KAAK,CAACiB,MAAM,KAAKhB,MAAM,CAACgB,MAAM,EAAE;IAClC,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAO;IAAElB,KAAK;IAAEC;EAAO,CAAC;AAC1B,CAAC;AACD,IAAIkB,cAAc,GAAIC,MAAM,IAAK;EAC/B,IAAI,CAACA,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE,OAAOzB,WAAW,CAACyB,MAAM,IAAI,EAAE,CAAC;EAC3E,OAAOrB,aAAa,CAACqB,MAAM,CAACpB,KAAK,CAACqB,GAAG,CAAC,CAAChB,IAAI,EAAEiB,KAAK,KAAK,CAACjB,IAAI,EAAEe,MAAM,CAACnB,MAAM,CAACqB,KAAK,CAAC,CAAC,CAAC,CAAC;AACvF,CAAC;AACD,IAAIC,YAAY,GAAIC,MAAM,IAAK;EAC7B,IAAI,CAACA,MAAM,EAAE,OAAO,EAAE;EACtB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE,OAAOA,MAAM;EAC7C,OAAOA,MAAM,CAACxB,KAAK,CAACqB,GAAG,CAAC,CAAChB,IAAI,EAAEiB,KAAK,KAAK,GAAGjB,IAAI,IAAImB,MAAM,CAACvB,MAAM,CAACqB,KAAK,CAAC,GAAG,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC;AACxF,CAAC;AAED,SACE9B,WAAW,EACXI,aAAa,EACbiB,cAAc,EACdG,cAAc,EACdI,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}