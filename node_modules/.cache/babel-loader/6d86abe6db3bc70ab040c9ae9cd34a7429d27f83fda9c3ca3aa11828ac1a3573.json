{"ast":null,"code":"/** @internal */\nexport const listenersCache = /*#__PURE__*/new Map();\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/new Map();\nlet callbackCount = 0;\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe(observerId, callbacks, fn) {\n  const callbackId = ++callbackCount;\n  const getListeners = () => listenersCache.get(observerId) || [];\n  const unsubscribe = () => {\n    const listeners = getListeners();\n    listenersCache.set(observerId, listeners.filter(cb => cb.id !== callbackId));\n  };\n  const unwatch = () => {\n    const cleanup = cleanupCache.get(observerId);\n    if (getListeners().length === 1 && cleanup) cleanup();\n    unsubscribe();\n  };\n  const listeners = getListeners();\n  listenersCache.set(observerId, [...listeners, {\n    id: callbackId,\n    fns: callbacks\n  }]);\n  if (listeners && listeners.length > 0) return unwatch;\n  const emit = {};\n  for (const key in callbacks) {\n    emit[key] = (...args) => {\n      const listeners = getListeners();\n      if (listeners.length === 0) return;\n      for (const listener of listeners) listener.fns[key]?.(...args);\n    };\n  }\n  const cleanup = fn(emit);\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup);\n  return unwatch;\n}","map":{"version":3,"names":["listenersCache","Map","cleanupCache","callbackCount","observe","observerId","callbacks","fn","callbackId","getListeners","get","unsubscribe","listeners","set","filter","cb","id","unwatch","cleanup","length","fns","emit","key","args","listener"],"sources":["C:\\Users\\seahs\\repos\\worldcoin-app\\node_modules\\@worldcoin\\idkit-core\\node_modules\\viem\\utils\\observe.ts"],"sourcesContent":["import type { ErrorType } from '../errors/utils.js'\nimport type { MaybePromise } from '../types/utils.js'\n\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport type ObserveErrorType = ErrorType\n\n/** @internal */\nexport const listenersCache = /*#__PURE__*/ new Map<\n  string,\n  { id: number; fns: Callbacks }[]\n>()\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/ new Map<string, () => void>()\n\ntype EmitFunction<callbacks extends Callbacks> = (\n  emit: callbacks,\n) => MaybePromise<void | (() => void)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<callbacks extends Callbacks>(\n  observerId: string,\n  callbacks: callbacks,\n  fn: EmitFunction<callbacks>,\n) {\n  const callbackId = ++callbackCount\n\n  const getListeners = () => listenersCache.get(observerId) || []\n\n  const unsubscribe = () => {\n    const listeners = getListeners()\n    listenersCache.set(\n      observerId,\n      listeners.filter((cb: any) => cb.id !== callbackId),\n    )\n  }\n\n  const unwatch = () => {\n    const cleanup = cleanupCache.get(observerId)\n    if (getListeners().length === 1 && cleanup) cleanup()\n    unsubscribe()\n  }\n\n  const listeners = getListeners()\n  listenersCache.set(observerId, [\n    ...listeners,\n    { id: callbackId, fns: callbacks },\n  ])\n\n  if (listeners && listeners.length > 0) return unwatch\n\n  const emit: callbacks = {} as callbacks\n  for (const key in callbacks) {\n    emit[key] = ((\n      ...args: Parameters<NonNullable<callbacks[keyof callbacks]>>\n    ) => {\n      const listeners = getListeners()\n      if (listeners.length === 0) return\n      for (const listener of listeners) listener.fns[key]?.(...args)\n    }) as callbacks[Extract<keyof callbacks, string>]\n  }\n\n  const cleanup = fn(emit)\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)\n\n  return unwatch\n}\n"],"mappings":"AAQA;AACA,OAAO,MAAMA,cAAc,GAAG,aAAc,IAAIC,GAAG,EAGhD;AACH;AACA,OAAO,MAAMC,YAAY,GAAG,aAAc,IAAID,GAAG,EAAsB;AAMvE,IAAIE,aAAa,GAAG,CAAC;AAErB;;;;;AAKA,OAAM,SAAUC,OAAOA,CACrBC,UAAkB,EAClBC,SAAoB,EACpBC,EAA2B;EAE3B,MAAMC,UAAU,GAAG,EAAEL,aAAa;EAElC,MAAMM,YAAY,GAAGA,CAAA,KAAMT,cAAc,CAACU,GAAG,CAACL,UAAU,CAAC,IAAI,EAAE;EAE/D,MAAMM,WAAW,GAAGA,CAAA,KAAK;IACvB,MAAMC,SAAS,GAAGH,YAAY,EAAE;IAChCT,cAAc,CAACa,GAAG,CAChBR,UAAU,EACVO,SAAS,CAACE,MAAM,CAAEC,EAAO,IAAKA,EAAE,CAACC,EAAE,KAAKR,UAAU,CAAC,CACpD;EACH,CAAC;EAED,MAAMS,OAAO,GAAGA,CAAA,KAAK;IACnB,MAAMC,OAAO,GAAGhB,YAAY,CAACQ,GAAG,CAACL,UAAU,CAAC;IAC5C,IAAII,YAAY,EAAE,CAACU,MAAM,KAAK,CAAC,IAAID,OAAO,EAAEA,OAAO,EAAE;IACrDP,WAAW,EAAE;EACf,CAAC;EAED,MAAMC,SAAS,GAAGH,YAAY,EAAE;EAChCT,cAAc,CAACa,GAAG,CAACR,UAAU,EAAE,CAC7B,GAAGO,SAAS,EACZ;IAAEI,EAAE,EAAER,UAAU;IAAEY,GAAG,EAAEd;EAAS,CAAE,CACnC,CAAC;EAEF,IAAIM,SAAS,IAAIA,SAAS,CAACO,MAAM,GAAG,CAAC,EAAE,OAAOF,OAAO;EAErD,MAAMI,IAAI,GAAc,EAAe;EACvC,KAAK,MAAMC,GAAG,IAAIhB,SAAS,EAAE;IAC3Be,IAAI,CAACC,GAAG,CAAC,GAAI,CACX,GAAGC,IAAyD,KAC1D;MACF,MAAMX,SAAS,GAAGH,YAAY,EAAE;MAChC,IAAIG,SAAS,CAACO,MAAM,KAAK,CAAC,EAAE;MAC5B,KAAK,MAAMK,QAAQ,IAAIZ,SAAS,EAAEY,QAAQ,CAACJ,GAAG,CAACE,GAAG,CAAC,GAAG,GAAGC,IAAI,CAAC;IAChE,CAAiD;EACnD;EAEA,MAAML,OAAO,GAAGX,EAAE,CAACc,IAAI,CAAC;EACxB,IAAI,OAAOH,OAAO,KAAK,UAAU,EAAEhB,YAAY,CAACW,GAAG,CAACR,UAAU,EAAEa,OAAO,CAAC;EAExE,OAAOD,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}